# -*- coding: utf-8 -*-
"""QOSF-Task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fk7ThKPpXrB4WwkYTAde0wxoN-fbrhJv

# [QOSF](https://qosf.org/) Cohort 4 [Screening Tasks](https://docs.google.com/document/d/1kG2YwNwYclN06iI506rlfrmLCZqFFmS7r_TxjVNLAa8/edit)

Author: Ali Panahi

# Task 2

## Problem Definition

Prepare 4 random 4-qubit quantum states of your choice.

Create and train a variational circuit that transforms input states into predefined output states. Namely

- if random state 1 is provided, it returns state |0011>
- if random state 2 is provided, it returns state |0101>
- if random state 3 is provided, it returns state |1010>
- if random state 4 is provided, it returns state |1100>

What would happen if you provided a different state?

Analyze and discuss the results.

Feel free to use existing frameworks (e.g. PennyLane, Qiskit) for creating and training the circuits.

This PennyLane demo can be useful: Training a quantum circuit with Pytorch, 
This Quantum Tensorflow tutorial can be useful: Training a quantum circuit with Tensorflow .

For the variational circuit, you can try any circuit you want. You can start from one with a layer of RX, RY and CNOTs, repeated a couple of times (though there are certainly better circuits to achieve this goal). 

Context:

This challenge has been inspired by the following papers “[A generative modeling approach for benchmarking and training shallow quantum circuits](https://www.nature.com/articles/s41534-019-0157-8)” and “[Generation of High-Resolution Handwritten Digits with an Ion-Trap Quantum Computer](https://arxiv.org/abs/2012.03924)“. The target states of this task can be interpreted as the 2x2 “bars and stripes” patterns used in the first paper.

## Solution

### Summary

We create four random 4-qubit quantum states by using H, X, Y, Z rotations and then using a parametrized circuit as the Ansatz we train the Tensorflow Quantum model. The Ansatz only has 19 parameters and is able to predict the final states for the current random seed with perfect accuracy.

Running the experiments with other seeds results in accuracy of 75% or more, assuming predicting the final state of each qubit as a classification problem.

The parameters land in a range of 0 to 8. 

### Install and Import Libraries
"""

from tensorflow import __version__
if __version__ != '2.4.1':
  !pip -q install tensorflow==2.4.1
  print('Restarting the Kernel ...')
  print('Run the notebook again.')
  import os
  os.kill(os.getpid(), 9)

try:
  import cirq
except ImportError:
  !pip -q install tensorflow-quantum cirq
  import cirq
  # !pip -q install qsimcirq

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
import tensorflow_quantum as tfq

import cirq
import sympy
import numpy as np

# visualization tools
# %matplotlib inline
import matplotlib.pyplot as plt
from cirq.contrib.svg import SVGCircuit

"""### Configurations"""

seed = 42        # For reproducibilty of the experiments
n = 4           # Number of qubits
num_samples = 4 # Number of training samples

qubits = cirq.GridQubit.rect(1, n)
np.random.seed(seed)
tf.random.set_seed(seed)

"""Prepare the desired output

"""

# The desired Z expectation value at output of quantum circuit.
y = np.array([
              [1,1,-1,-1],   # |0011>
              [1,-1,1,-1],   # |0101>
              [-1,1,-1,1],   # |1010>
              [-1,-1,1,1]    # |1100>
              ], dtype=np.float32)

"""### Create random qubatum states of choice"""

def single_qubit_wall(qubits, rotations, gates):
  """Prepare a "single qubit rotations" around `gates` wall on `qubits`."""
  wall_circuit = cirq.Circuit()
  for i, qubit in enumerate(qubits):
    for j, gate in enumerate(gates):
      wall_circuit.append(gate(qubit) ** rotations[i][j])

  return wall_circuit

gates = [cirq.H, cirq.X, cirq.Y, cirq.Z]
quantum_data_circuit = [single_qubit_wall(qubits, np.random.uniform(size=(n, len(gates))), gates) for i in range(num_samples)]

# The quantum_data_circuit has `num_samples` circuits. Let's look at the first one.
SVGCircuit(quantum_data_circuit[0])

# Convert the cirq Circuit object to 
quantum_data = tfq.convert_to_tensor(quantum_data_circuit)
quantum_data.shape

"""### Ansatz"""

def ansatz_builder(qubits):
  """Parametrized Circuit builder for the ansatz"""
  
  wall_circuit = cirq.Circuit()
  gates = [
           cirq.rx, cirq.ry,  cirq.rz
           ] 
  for i, qubit in enumerate(qubits):
    j = i - 1
    if i == 0:
      j = len(qubits) - 1 # Only for the purpose of parameter name
    control_params = sympy.symbols(f'cx{i}{j}')
    wall_circuit.append(cirq.CXPowGate(exponent=control_params)(qubits[i], qubits[j]))
    for k, gate in enumerate(gates):
      control_params = sympy.symbols(f'{gate.__name__}{i}_:{len(gates)}')
      wall_circuit.append(gate(control_params[k])(qubit))
    control_params = sympy.symbols(f'cx{k}{i}')
    wall_circuit.append(cirq.CXPowGate(exponent=control_params)(qubits[j], qubits[i]))

  return wall_circuit

ansatz_parametrized_circut = ansatz_builder(qubits)
print('Ansatz:')
SVGCircuit(ansatz_parametrized_circut)

# TFQ layer for 
pqc = tfq.layers.PQC(ansatz_parametrized_circut,
                     # Observe Z
                     operators = [cirq.Z(q) for q in qubits], name='ansatz')

# Build the Keras model.
model = tf.keras.Sequential([
    # The input is the data-circuit, encoded as a tf.string
    tf.keras.layers.Input(shape=(), dtype=tf.string),
    # The PQC layer returns the expected values
    pqc,
])
model.summary()

tf.keras.utils.plot_model(model, show_shapes=True, dpi=100)

@tf.function
def hinge_accuracy(y_true, y_pred):
    y_true = tf.squeeze(y_true) > 0.0
    y_pred = tf.squeeze(y_pred) > 0.0
    result = tf.cast(y_true == y_pred, tf.float32)

    return tf.reduce_mean(result)

from datetime import datetime
optimizer = tf.keras.optimizers.Adam(learning_rate=0.1)
def datetime_():
  return datetime.now().strftime("%d/%m/%Y %H:%M:%S")
tensorboard_callback = tf.compat.v1.keras.callbacks.TensorBoard(log_dir="./logs/"+datetime_(), histogram_freq=2)
loss = tf.keras.losses.MeanSquaredError()
model.compile(optimizer=optimizer,
              loss=loss,
              metrics=[hinge_accuracy])

"""## Train the Ansatz"""

history = model.fit(x=quantum_data,
                    y=y,
                    epochs=150,
                    verbose=0,
                    callbacks=[tensorboard_callback])

model.evaluate(quantum_data, y)

"""### Visualize the results"""

plt.plot(history.history['loss'])
plt.title("Learning to Control a Qubit")
plt.xlabel("Iterations")
plt.ylabel("Error in Control")
plt.show()

y_pred = model(quantum_data)
y_pred

ae = tf.abs(tf.sign(y_pred) - y)/2
print(ae)
print('mae:', tf.reduce_mean(tf.abs(tf.sign(y_pred) - y)).numpy())

model.layers[0].parameters # or print(pqc.parameters)

